<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EHR MCP Tool (In-Browser)</title>
    <style>
        body { font-family: sans-serif; padding: 1em; }
        pre { background-color: #f4f4f4; padding: 1em; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; max-height: 400px; overflow-y: auto; }
        code { font-family: monospace; }
        .status { margin-bottom: 1em; font-weight: bold; padding: 0.5em; border-radius: 4px; }
        .status-error { color: red; background-color: #fce8e6; border: 1px solid red; }
        .status-loading { color: #333; background-color: #eee; border: 1px solid #ccc; }
        .status-ready { color: green; background-color: #e7f4e7; border: 1px solid green; }
        .test-section fieldset { margin-bottom: 1em; padding: 1em; border: 1px solid #ddd; border-radius: 4px; }
        .test-section legend { font-weight: bold; padding: 0 0.5em; }
        .test-section label { display: block; margin: 0.5em 0; }
        .test-section input[type="text"], .test-section input[type="number"], .test-section select { margin-left: 5px; }
        .test-section button { margin-top: 0.5em; }
    </style>
</head>
<body>
    <h1>EHR MCP Tool (In-Browser)</h1>
    <div id="toolStatus" class="status status-loading">Loading configuration and initializing...</div>
    <h4>Log:</h4>
    <pre id="log">Initializing...
</pre>

    <hr>
    <h2>Test UI</h2>
    <p>Manually call the registered tools. Results will appear in the log above.</p>

    <div class="test-section" id="test-ui-container" style="display: none;">
        <!-- Grep Record -->
        <fieldset>
            <legend><strong>grep_record</strong></legend>
            <label>Query (Regex): <input type="text" id="grepQuery" value="patient|condition"></label>
            <label>Resource Types (comma-separated, empty for all): <input type="text" id="grepResourceTypes" placeholder="Condition,Observation,Attachment"></label>
            <label>Resource Format:
                <select id="grepResourceFormat">
                    <option value="plaintext" selected>plaintext</option>
                    <option value="json">json</option>
                </select>
            </label>
            <label>Page: <input type="number" id="grepPage" value="1" min="1" style="width: 60px;"></label>
            <label>Page Size: <input type="number" id="grepPageSize" value="10" min="1" max="50" style="width: 60px;"></label>
            <button id="grepBtn">Run Grep</button>
            <div style="margin-top: 1em;">
                <strong>Result (Markdown):</strong>
                <pre id="grepResult" style="background:#eee; padding: 5px; border: 1px solid #ccc; max-height: 300px; overflow: auto;">[Result will appear here]</pre>
            </div>
        </fieldset>

        <!-- Read Resource -->
        <fieldset>
            <legend><strong>read_resource</strong></legend>
            <label>Resource Type: <input type="text" id="readResourceType" placeholder="Patient"></label>
            <label>Resource ID: <input type="text" id="readResourceId" placeholder="example-patient-id"></label>
            <button id="readResourceBtn">Read Resource</button>
            <div style="margin-top: 1em;">
                <strong>Result:</strong>
                <pre id="readResourceResult" style="background:#eee; padding: 5px; border: 1px solid #ccc; max-height: 300px; overflow: auto;">[Result will appear here]</pre>
            </div>
        </fieldset>

        <!-- Read Attachment -->
        <fieldset>
            <legend><strong>read_attachment</strong></legend>
            <label>Resource Type: <input type="text" id="attachResourceType" placeholder="DocumentReference"></label>
            <label>Resource ID: <input type="text" id="attachResourceId" placeholder="example-doc-id"></label>
            <label>Attachment Path: <input type="text" id="attachPath" placeholder="content.attachment"></label>
            <label><input type="checkbox" id="attachIncludeBase64"> Include Raw Base64</label>
            <button id="readAttachmentBtn">Read Attachment</button>
            <div style="margin-top: 1em;">
                <strong>Result (Markdown):</strong>
                <pre id="readAttachmentResult" style="background:#eee; padding: 5px; border: 1px solid #ccc; max-height: 300px; overflow: auto;">[Result will appear here]</pre>
            </div>
        </fieldset>
    </div>

    <script type="module">
        // --- Imports ---
        // Dynamically import the MCP Server Library
        const MCPToolServerModule = await import('../intralib.js');
        const MCPToolServer = MCPToolServerModule.default || MCPToolServerModule;

        // Dynamically import the bundled browser-safe tool logic
        // This assumes the build step has run successfully
        const ToolLogicModule = await import('./dist/tools.js');
        const {
            // Import the JSON Schema objects generated during build
            GrepRecordInputJsonSchema,
            ReadResourceInputJsonSchema,
            ReadAttachmentInputJsonSchema,
            // Import logic functions
            grepRecordLogic,
            readResourceLogic,
            readAttachmentLogic
        } = ToolLogicModule;

        // --- Constants, Config Param and Elements ---
        const urlParams = new URLSearchParams(location.search);
        const configKey = urlParams.get('config') || 'global';

        const dataKey = `ehrJsonData::${configKey}`;
        const originsKey = `ehrMcpAllowedOrigins::${configKey}`;

        const logElement = document.getElementById('log');
        const statusElement = document.getElementById('toolStatus');
        const DB_NAME = 'ehrMcpDB';
        const STORE_NAME = 'configuration';

        // --- State ---
        let fullEhr = null; // Will hold the parsed EHR JSON
        let allowedOrigins = '*'; // Default allowed origins
        let mcpServer = null;

        // --- Helper Functions ---
        function log(message, ...args) {
            console.log('[EHR Tool]', message, ...args);
            if (logElement) {
                const time = new Date().toLocaleTimeString();
                logElement.textContent += `[${time}] ${message}${args.length > 0 ? ' ' + args.map(a => JSON.stringify(a)).join(' ') : ''}\n`;
                logElement.scrollTop = logElement.scrollHeight; // Scroll to bottom
            }
        }

        function setStatus(message, type = 'loading') {
            log(`Status: ${message}`);
            if (statusElement) {
                statusElement.textContent = message;
                statusElement.className = `status status-${type}`;
            }
        }

        // --- IndexedDB Helper to Load Data ---
        function openDB() {
             return new Promise((resolve, reject) => {
                 // Check if IndexedDB is supported
                 if (!window.indexedDB) {
                     reject("IndexedDB not supported by this browser.");
                     return;
                 }
                 const request = indexedDB.open(DB_NAME, 1); // Use same version as configure.html

                 request.onerror = (event) => {
                     console.error("IndexedDB error:", event.target.error);
                     reject(`IndexedDB error: ${event.target.error?.message}`);
                 };

                 request.onsuccess = (event) => {
                     resolve(event.target.result);
                 };

                 // No upgrade needed here, assuming configure.html created it
                 request.onupgradeneeded = (event) => {
                      console.warn("IndexedDB upgrade needed during load? This shouldn't happen if configure.html ran.");
                      // If needed, you could recreate the store here
                      // const db = event.target.result;
                      // if (!db.objectStoreNames.contains(STORE_NAME)) {
                      //     db.createObjectStore(STORE_NAME);
                      // }
                      // For robustness, let's allow the success handler to proceed
                 };
             });
        }

        async function loadEhrDataFromDB() {
            try {
                const db = await openDB();
                return new Promise((resolve, reject) => {
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.close();
                        reject(`IndexedDB object store '${STORE_NAME}' not found. Please run configuration page first.`);
                        return;
                    }
                    const transaction = db.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.get(dataKey);

                    request.onerror = (event) => {
                        console.error('Error reading data from IndexedDB:', event.target.error);
                        reject(`Error reading data: ${event.target.error?.message}`);
                    };

                    request.onsuccess = (event) => {
                        const result = event.target.result;
                        if (result && result.content) {
                            resolve(result.content); // Return the stored JSON string
                        } else {
                            resolve(null); // Indicate data not found
                        }
                    };

                    transaction.oncomplete = () => {
                        db.close();
                    };
                    transaction.onerror = (event) => {
                        console.error('IndexedDB readonly transaction error:', event.target.error);
                        reject(`DB Read Transaction error: ${event.target.error?.message}`);
                    };
                });
            } catch (dbError) {
                // Catch errors from openDB itself
                 console.error("Failed to open IndexedDB:", dbError);
                 throw new Error(`Failed to access IndexedDB: ${dbError}`); // Re-throw to be caught by main init
            }
        }

        // --- Main Initialization Function ---
        async function initializeTool() {
            log('Attempting to load configuration...');
            try {
                // 1. Load Allowed Origins from LocalStorage
                const storedOrigins = localStorage.getItem(originsKey);
                if (storedOrigins) {
                    allowedOrigins = storedOrigins;
                    log(`Loaded allowed origins: ${allowedOrigins}`);
                } else {
                    log(`Using default allowed origins: ${allowedOrigins}`);
                }

                // 2. Load EHR Data from IndexedDB
                setStatus('Loading EHR data from IndexedDB...');
                const ehrDataString = await loadEhrDataFromDB();

                if (!ehrDataString) {
                    throw new Error('EHR data not found in IndexedDB. Please run the configuration page (ehr-mcp/configure.html) first.');
                }

                // 3. Parse EHR Data
                setStatus('Parsing EHR data...');
                try {
                    fullEhr = JSON.parse(ehrDataString);
                    // Basic validation of the parsed structure
                    if (!fullEhr || typeof fullEhr.fhir !== 'object' || !Array.isArray(fullEhr.attachments)) {
                        throw new Error('Parsed EHR data does not have the expected structure (missing fhir object or attachments array).');
                    }
                    log(`Successfully parsed EHR data. FHIR resource types: ${Object.keys(fullEhr.fhir || {}).length}, Attachments: ${fullEhr.attachments?.length ?? 0}`);
                } catch (parseError) {
                     console.error("Failed to parse EHR JSON from IndexedDB:", parseError);
                     throw new Error(`Failed to parse stored EHR data: ${parseError.message}`);
                }

                // 4. Initialize MCP Server Library
                setStatus('Initializing MCP Tool Server...');
                mcpServer = new MCPToolServer({
                    serverInfo: {
                        name: "in-browser-ehr-mcp-tool",
                        version: "1.0.0"
                    },
                    targetOrigin: allowedOrigins, // Use loaded/default origins
                    debug: true
                });

                // 5. Register Tools using the pre-converted JSON schemas
                setStatus('Registering tools...');

                // Grep Record Tool
                mcpServer.registerTool({
                    name: "grep_record",
                    description: "Searches EHR resources and attachment text using a regex.",
                    // Use the imported JSON Schema object directly
                    inputSchema: GrepRecordInputJsonSchema
                }, async (args) => {
                    log("Handling grep_record call:", args);
                    if (!fullEhr) return { content: [{ type: 'text', text: '**Error:** EHR data not loaded.' }], isError: true };
                    try {
                        // Note: grepRecordLogic expects ClientFullEHR type
                        const resultString = await grepRecordLogic(
                            fullEhr, 
                            args.query,
                            args.resource_types,
                            args.resource_format || 'plaintext',
                            args.page_size,
                            args.page
                        );
                         const isError = resultString.startsWith('**Error:**');
                        log(`grep_record result (isError: ${isError}):`, resultString.substring(0, 100) + "...");
                         return { content: [{ type: "text", text: resultString }], isError: isError };
                    } catch (error) {
                        log("Error in grepRecordLogic:", error);
                         return { content: [{ type: 'text', text: `**Error:** ${error.message}` }], isError: true };
                    }
                });

                // Read Resource Tool
                mcpServer.registerTool({
                    name: "read_resource",
                    description: "Reads a specific FHIR resource by type and ID.",
                    inputSchema: ReadResourceInputJsonSchema
                }, async (args) => {
                    log("Handling read_resource call:", args);
                    if (!fullEhr) return { content: [{ type: 'text', text: '{"error": "EHR data not loaded."}' }], isError: true };
                     try {
                        const resultString = await readResourceLogic(fullEhr, args.resourceType, args.resourceId);
                        const isError = resultString.includes('"error":');
                        log(`read_resource result (isError: ${isError}):`, resultString);
                        return { content: [{ type: "text", text: resultString }], isError: isError };
                    } catch (error) {
                        log("Error in readResourceLogic:", error);
                         return { content: [{ type: 'text', text: JSON.stringify({ error: `Internal error: ${error.message}` }) }], isError: true };
                    }
                });

                // Read Attachment Tool
                mcpServer.registerTool({
                    name: "read_attachment",
                    description: "Reads the content of a specific attachment.",
                    inputSchema: ReadAttachmentInputJsonSchema
                }, async (args) => {
                    log("Handling read_attachment call:", args);
                    if (!fullEhr) return { content: [{ type: 'text', text: '**Error:** EHR data not loaded.' }], isError: true };
                    try {
                        const resultString = await readAttachmentLogic(fullEhr, args.resourceType, args.resourceId, args.attachmentPath, args.includeRawBase64);
                        const isError = resultString.startsWith('**Error:**');
                         log(`read_attachment result (isError: ${isError}):`, resultString.substring(0, 100) + "...");
                        return { content: [{ type: "text", text: resultString }], isError: isError };
                    } catch (error) {
                        log("Error in readAttachmentLogic:", error);
                        return { content: [{ type: 'text', text: `**Error:** ${error.message}` }], isError: true };
                    }
                });

                log('Tools registered.');
                // Signal to parent window that server is ready to handle requests
                mcpServer.sendReadySignal();

                setStatus('Ready. Listening for MCP messages.', 'ready');

                // --- Enable Test UI --- 
                setupTestUI(); // Call setup function after successful init

            } catch (error) {
                console.error("Initialization failed:", error);
                setStatus(`Error initializing tool: ${error.message}`, 'error');
            }
        }

        // --- Test UI Setup and Handlers ---
        function setupTestUI() {
            const testUiContainer = document.getElementById('test-ui-container');
            const grepResultEl = document.getElementById('grepResult');
            const readResourceResultEl = document.getElementById('readResourceResult');
            const readAttachmentResultEl = document.getElementById('readAttachmentResult'); // Get attachment result element

            if (!mcpServer || !fullEhr) { // Also check if fullEhr is loaded
                log("MCP Server or EHR data not ready, cannot set up Test UI.");
                return;
            }
            testUiContainer.style.display = 'block'; // Show the UI

            // REMOVE callCounter and request ID tracking - no longer needed for test UI
            // let callCounter = 1;
            // let lastReadResourceId = null;
            // let lastGrepRequestId = null;

            // REMOVE sendToolCall helper - no longer needed for test UI
            // function sendToolCall(...) { ... }

            // Grep Button - UPDATED
            document.getElementById('grepBtn').addEventListener('click', async () => { // Make async
                const query = document.getElementById('grepQuery').value;
                const typesRaw = document.getElementById('grepResourceTypes').value;
                const format = document.getElementById('grepResourceFormat').value;
                const page = parseInt(document.getElementById('grepPage').value, 10);
                const pageSize = parseInt(document.getElementById('grepPageSize').value, 10);

                if (!query) {
                    alert('Grep Query cannot be empty.');
                    return;
                }
                
                grepResultEl.textContent = '[Running grep...]'; // Update UI
                try {
                    const resource_types = typesRaw.trim() ? typesRaw.split(',').map(s => s.trim()).filter(Boolean) : undefined;
                    const page_num = (!isNaN(page) && page >= 1) ? page : undefined;
                    const page_size_num = (!isNaN(pageSize) && pageSize >= 1) ? pageSize : undefined;


                    // Call the logic function directly
                    const resultString = await grepRecordLogic(
                        fullEhr,
                        query,
                        resource_types,
                        format,
                        page_size_num, // Pass potentially undefined value
                        page_num       // Pass potentially undefined value
                    );
                    grepResultEl.textContent = resultString; // Display result directly

                } catch (error) {
                    grepResultEl.textContent = `Error running grep:
${error.message}`;
                }
            });

            // Read Resource Button - UPDATED
            document.getElementById('readResourceBtn').addEventListener('click', async () => { // Make async
                const resourceType = document.getElementById('readResourceType').value;
                const resourceId = document.getElementById('readResourceId').value;
                if (!resourceType || !resourceId) {
                    alert('Resource Type and Resource ID are required.');
                    return;
                }
                readResourceResultEl.textContent = '[Reading resource...]'; // Update UI
                try {
                    // Call the logic function directly
                    const resultString = await readResourceLogic(fullEhr, resourceType, resourceId);
                    // Parse and display
                    try {
                        const resultData = JSON.parse(resultString);
                        if (resultData.error) {
                            readResourceResultEl.textContent = `Tool Returned Error:
${JSON.stringify(resultData.error, null, 2)}`;
                        } else if (resultData.resource) {
                            readResourceResultEl.textContent = JSON.stringify(resultData.resource, null, 2);
                        } else if (resultData.resource === null) {
                            readResourceResultEl.textContent = `[Resource Not Found]`;
                        } else {
                            readResourceResultEl.textContent = `Unexpected result format:
${resultString}`;
                        }
                    } catch (parseError) {
                         readResourceResultEl.textContent = `Error parsing result:
${resultString}`;
                    }
                } catch (error) {
                    readResourceResultEl.textContent = `Error reading resource:
${error.message}`;
                }
            });

            // Read Attachment Button - UPDATED
            document.getElementById('readAttachmentBtn').addEventListener('click', async () => { // Make async
                const resourceType = document.getElementById('attachResourceType').value;
                const resourceId = document.getElementById('attachResourceId').value;
                const attachmentPath = document.getElementById('attachPath').value;
                const includeRawBase64 = document.getElementById('attachIncludeBase64').checked;

                if (!resourceType || !resourceId || !attachmentPath) {
                    alert('Resource Type, Resource ID, and Attachment Path are required.');
                    return;
                }
                
                readAttachmentResultEl.textContent = '[Reading attachment...]'; // Update UI
                log("--- Test UI: Calling readAttachmentLogic directly ---", {resourceType, resourceId, attachmentPath, includeRawBase64});
                 try {
                     // Call the logic function directly
                     const resultString = await readAttachmentLogic(fullEhr, resourceType, resourceId, attachmentPath, includeRawBase64);
                     log("--- Test UI: readAttachmentLogic result --- \n" + resultString); // Log the markdown result
                     readAttachmentResultEl.textContent = resultString; // Display result directly
                 } catch (error) {
                     log("--- Test UI: Error calling readAttachmentLogic ---", error);
                     readAttachmentResultEl.textContent = `Error reading attachment:
${error.message}`; // Report error in UI
                 }
            });

            // REMOVE the message listener for test responses - no longer needed
            // window.addEventListener('message', (event) => { ... });
            // ---------------------------------------------------------------------------
        }

        // --- Start Initialization ---
        initializeTool();

    </script>
</body>
</html> 